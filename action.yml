name: Resolve Vars
description: |
  Resolve variables using a combination of (1) pre-built resolutions, (2) static inputs, and (3) Jinja2 expressions.
inputs:
  static_inputs:
    description: >
      Variable assignments in key=value format (multiline string).
      Each line should be in the format: variable_name=value
  jinja_inputs:
    description: >
      Jinja2 expression to evaluate (e.g. user or default_user)
    required: false
  log_outputs:
    description: >
      Whether to log the resolved value (default false). This can be enabled if
      inputs and outputs are non-sensitive. you can also use this for sensitive
      values IIF you are confident you have masked sensitive values using
      GitHub secret masking.
    default: 'false'
    required: false
  non_sensitive:
    description: >
      Alias for log_outputs (true = show evaluated output)
    default: 'false'
    required: false
outputs:
  custom:
    value: ${{ steps.merge-results.outputs.custom }}
    description: 'JSON-encoded object with all resolved values'
  # Resolved Variables (always the effective context)
  resolved-git-ref:
    value: ${{ steps.merge-results.outputs.resolved-git-ref }}
    description: 'Full Git ref (refs/heads/... or refs/tags/...)'
  resolved-git-branch:
    value: ${{ steps.merge-results.outputs.resolved-git-branch }}
    description: 'Short branch name (e.g. main, feature/foo)'
  resolved-git-sha:
    value: ${{ steps.merge-results.outputs.resolved-git-sha }}
    description: 'Commit SHA'
  resolved-git-tag:
    value: ${{ steps.merge-results.outputs.resolved-git-tag }}
    description: 'Tag name (if applicable)'
  resolved-repo-name:
    value: ${{ steps.merge-results.outputs.resolved-repo-name }}
    description: 'Repository name (e.g. my-repo)'
  resolved-repo-owner:
    value: ${{ steps.merge-results.outputs.resolved-repo-owner }}
    description: 'Repository owner (user or org)'
  resolved-repo-name-full:
    value: ${{ steps.merge-results.outputs.resolved-repo-name-full }}
    description: 'Owner + name (e.g. myorg/my-repo)'
  resolved-git-branch-url:
    value: ${{ steps.merge-results.outputs.resolved-git-branch-url }}
    description: 'URL to the branch in GitHub'
  resolved-git-commit-url:
    value: ${{ steps.merge-results.outputs.resolved-git-commit-url }}
    description: 'URL to the commit in GitHub'
  # PR Source Variables
  pr-source-git-ref:
    value: ${{ steps.merge-results.outputs.pr-source-git-ref }}
    description: 'Git ref of the source (PR head)'
  pr-source-git-branch:
    value: ${{ steps.merge-results.outputs.pr-source-git-branch }}
    description: 'Branch name of the source'
  pr-source-git-sha:
    value: ${{ steps.merge-results.outputs.pr-source-git-sha }}
    description: 'SHA of the source commit'
  pr-source-repo-name:
    value: ${{ steps.merge-results.outputs.pr-source-repo-name }}
    description: 'Source repo name'
  pr-source-repo-owner:
    value: ${{ steps.merge-results.outputs.pr-source-repo-owner }}
    description: 'Source repo owner'
  pr-source-repo-name-full:
    value: ${{ steps.merge-results.outputs.pr-source-repo-name-full }}
    description: 'Full source repo name (owner/name)'
  pr-source-git-branch-url:
    value: ${{ steps.merge-results.outputs.pr-source-git-branch-url }}
    description: 'URL to the source branch'
  pr-source-git-commit-url:
    value: ${{ steps.merge-results.outputs.pr-source-git-commit-url }}
    description: 'URL to the source commit'
  pr-source-is-fork:
    value: ${{ steps.merge-results.outputs.pr-source-is-fork }}
    description: 'Whether the source repo is a fork'
  # PR Target Variables
  pr-target-git-ref:
    value: ${{ steps.merge-results.outputs.pr-target-git-ref }}
    description: 'Git ref of the target (PR base)'
  pr-target-git-branch:
    value: ${{ steps.merge-results.outputs.pr-target-git-branch }}
    description: 'Branch name of the target'
  pr-target-git-sha:
    value: ${{ steps.merge-results.outputs.pr-target-git-sha }}
    description: 'SHA of the target commit'
  pr-target-git-tag:
    value: ${{ steps.merge-results.outputs.pr-target-git-tag }}
    description: 'Tag name, if PR targets a tag'
  pr-target-repo-name:
    value: ${{ steps.merge-results.outputs.pr-target-repo-name }}
    description: 'Target repo name'
  pr-target-repo-owner:
    value: ${{ steps.merge-results.outputs.pr-target-repo-owner }}
    description: 'Target repo owner'
  pr-target-repo-name-full:
    value: ${{ steps.merge-results.outputs.pr-target-repo-name-full }}
    description: 'Full target repo name (owner/name)'
  pr-target-git-branch-url:
    value: ${{ steps.merge-results.outputs.pr-target-git-branch-url }}
    description: 'URL to the target branch'
  pr-target-git-commit-url:
    value: ${{ steps.merge-results.outputs.pr-target-git-commit-url }}
    description: 'URL to the target commit'
  # PR Variables
  pr-number:
    value: ${{ steps.merge-results.outputs.pr-number }}
    description: 'Pull request number (if applicable)'
  pr-url:
    value: ${{ steps.merge-results.outputs.pr-url }}
    description: 'URL to the pull request'
  pr-title:
    value: ${{ steps.merge-results.outputs.pr-title }}
    description: 'Title of the pull request'
  # Comment Variables
  comment-id:
    value: ${{ steps.merge-results.outputs.comment-id }}
    description: 'ID of the triggering comment (if applicable)'
  comment-url:
    value: ${{ steps.merge-results.outputs.comment-url }}
    description: 'URL to the triggering comment (if applicable)'
  # Additional Resolved Metadata
  run-id:
    value: ${{ steps.merge-results.outputs.run-id }}
    description: 'GitHub Actions run ID'
  run-url:
    value: ${{ steps.merge-results.outputs.run-url }}
    description: 'URL to the GitHub Actions run'
  is-pr:
    value: ${{ steps.merge-results.outputs.is-pr }}
    description: 'Boolean: whether the current context is a PR'
  # Legacy outputs
  var1:
    value: ${{ steps.merge-results.outputs.var1 }}
    description: 'Custom user-defined output variable 1'
  var2:
    value: ${{ steps.merge-results.outputs.var2 }}
    description: 'Custom user-defined output variable 2'
  var3:
    value: ${{ steps.merge-results.outputs.var3 }}
    description: 'Custom user-defined output variable 3'
runs:
  using: "composite"
  steps:
    - id: resolve
      shell: bash
      run: |
        declare -A RESOLVED_VARS

        # Process static_inputs
        if [[ -n "${{ inputs.static_inputs }}" ]]; then
          echo "Processing static inputs..."

          # Read the multiline input and process each line
          while IFS= read -r line; do
            # Skip empty lines and comments
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

            # Split on first = character
            if [[ "$line" =~ ^([^=]+)=(.*)$ ]]; then
              var_name="${BASH_REMATCH[1]}"
              var_value="${BASH_REMATCH[2]}"

              # Trim whitespace from variable name
              var_name=$(echo "$var_name" | xargs)

              echo "Found variable: $var_name = $var_value"

              # Store in associative array
              RESOLVED_VARS["$var_name"]="$var_value"

              # Output each variable as individual output
              echo "$var_name=$var_value" >> "$GITHUB_OUTPUT"
            fi
          done <<< "${{ inputs.static_inputs }}"
        fi

        # Process jinja_inputs if provided
        if [[ -n "${{ inputs.jinja_inputs }}" ]]; then
          echo "Processing Jinja inputs..."

          # Create temporary files in the workspace (accessible to Docker containers)
          temp_vars_file="$GITHUB_WORKSPACE/.temp_vars.json"
          temp_jinja_template="$GITHUB_WORKSPACE/.temp_template.j2"
          temp_jinja_output="$GITHUB_WORKSPACE/.temp_output.txt"

          # Write current resolved variables to JSON file using jq
          json_vars="{}"
          for var_name in "${!RESOLVED_VARS[@]}"; do
            json_vars=$(echo "$json_vars" | jq --arg key "$var_name" --arg value "${RESOLVED_VARS[$var_name]}" '. + {($key): $value}')
          done
          echo "$json_vars" > "$temp_vars_file"

          # Save jinja_inputs and temp files to environment for next step
          # Set environment variables for the jinja renderer
          echo "TEMP_VARS_FILE=$temp_vars_file" >> "$GITHUB_ENV"
          echo "TEMP_JINJA_TEMPLATE=$temp_jinja_template" >> "$GITHUB_ENV"
          echo "TEMP_JINJA_OUTPUT=$temp_jinja_output" >> "$GITHUB_ENV"
        fi

        # Create initial JSON with static variables
        json_payload="{"
        first=true
        for var_name in "${!RESOLVED_VARS[@]}"; do
          if [[ "$first" == "true" ]]; then
            first=false
          else
            json_payload+=","
          fi
          # Properly escape the value for JSON using jq
          escaped_value=$(jq -R . <<< "${RESOLVED_VARS[$var_name]}")
          json_payload+="\"$var_name\":${escaped_value}"
        done
        json_payload+="}"

        # Save initial JSON for potential jinja processing
        echo "INITIAL_JSON=$json_payload" >> "$GITHUB_ENV"

    # Check GitHub CLI availability
    - id: check-gh-cli
      shell: bash
      run: |
        if command -v gh >/dev/null 2>&1; then
          echo "gh-available=true" >> "$GITHUB_OUTPUT"
        else
          echo "gh-available=false" >> "$GITHUB_OUTPUT"
          echo "Warning: GitHub CLI (gh) not available. PR resolution will be limited."
        fi

    # Process standard CI variables
    - id: resolve-standard-ci-vars
      shell: bash
      run: |
        declare -A CI_VARS
        
        # Resolved Variables (always the effective context)
        # For PRs: resolved = source (head), for other contexts: resolved = current
        if [[ "${{ github.event_name }}" == "pull_request" || "${{ github.event_name }}" == "pull_request_target" ]]; then
          CI_VARS["resolved-git-ref"]="refs/heads/${{ github.head_ref || github.ref_name }}"
          CI_VARS["resolved-git-branch"]="${{ github.head_ref || github.ref_name }}"
          CI_VARS["resolved-git-sha"]="${{ github.event.pull_request.head.sha || github.sha }}"
          CI_VARS["resolved-repo-name-full"]="${{ github.event.pull_request.head.repo.full_name || github.repository }}"
          CI_VARS["resolved-repo-owner"]="${{ github.event.pull_request.head.repo.owner.login || github.repository_owner }}"
          resolved_repo_name="${{ github.event.pull_request.head.repo.name }}"
          if [[ -z "$resolved_repo_name" ]]; then
            resolved_repo_full="${{ github.event.pull_request.head.repo.full_name || github.repository }}"
            resolved_repo_name="${resolved_repo_full##*/}"
          fi
          CI_VARS["resolved-repo-name"]="$resolved_repo_name"
        else
          CI_VARS["resolved-git-ref"]="${{ github.ref }}"
          CI_VARS["resolved-git-branch"]="${{ github.ref_name }}"
          CI_VARS["resolved-git-sha"]="${{ github.sha }}"
          CI_VARS["resolved-repo-name-full"]="${{ github.repository }}"
          CI_VARS["resolved-repo-owner"]="${{ github.repository_owner }}"
          repo_name="${{ github.event.repository.name }}"
          if [[ -z "$repo_name" ]]; then
            repo_full="${{ github.repository }}"
            repo_name="${repo_full##*/}"
          fi
          CI_VARS["resolved-repo-name"]="$repo_name"
        fi
        
        # Generate URLs for resolved context
        CI_VARS["resolved-git-branch-url"]="https://github.com/${CI_VARS["resolved-repo-name-full"]}/tree/${CI_VARS["resolved-git-branch"]}"
        CI_VARS["resolved-git-commit-url"]="https://github.com/${CI_VARS["resolved-repo-name-full"]}/commit/${CI_VARS["resolved-git-sha"]}"
        
        # Git tag (if applicable)
        if [[ "${{ github.ref }}" =~ ^refs/tags/ ]]; then
          CI_VARS["resolved-git-tag"]="${{ github.ref_name }}"
        else
          CI_VARS["resolved-git-tag"]=""
        fi
        
        # PR Source and Target Variables (only for PR events)
        if [[ "${{ github.event_name }}" == "pull_request" || "${{ github.event_name }}" == "pull_request_target" ]]; then
          # PR Source (head)
          CI_VARS["pr-source-git-ref"]="refs/heads/${{ github.head_ref }}"
          CI_VARS["pr-source-git-branch"]="${{ github.head_ref }}"
          CI_VARS["pr-source-git-sha"]="${{ github.event.pull_request.head.sha }}"
          CI_VARS["pr-source-repo-name-full"]="${{ github.event.pull_request.head.repo.full_name }}"
          CI_VARS["pr-source-repo-owner"]="${{ github.event.pull_request.head.repo.owner.login }}"
          CI_VARS["pr-source-repo-name"]="${{ github.event.pull_request.head.repo.name }}"
          CI_VARS["pr-source-is-fork"]="${{ github.event.pull_request.head.repo.fork }}"
          CI_VARS["pr-source-git-branch-url"]="https://github.com/${CI_VARS["pr-source-repo-name-full"]}/tree/${CI_VARS["pr-source-git-branch"]}"
          CI_VARS["pr-source-git-commit-url"]="https://github.com/${CI_VARS["pr-source-repo-name-full"]}/commit/${CI_VARS["pr-source-git-sha"]}"
          
          # PR Target (base)
          CI_VARS["pr-target-git-ref"]="refs/heads/${{ github.base_ref }}"
          CI_VARS["pr-target-git-branch"]="${{ github.base_ref }}"
          CI_VARS["pr-target-git-sha"]="${{ github.event.pull_request.base.sha }}"
          CI_VARS["pr-target-repo-name-full"]="${{ github.event.pull_request.base.repo.full_name }}"
          CI_VARS["pr-target-repo-owner"]="${{ github.event.pull_request.base.repo.owner.login }}"
          CI_VARS["pr-target-repo-name"]="${{ github.event.pull_request.base.repo.name }}"
          CI_VARS["pr-target-git-branch-url"]="https://github.com/${CI_VARS["pr-target-repo-name-full"]}/tree/${CI_VARS["pr-target-git-branch"]}"
          CI_VARS["pr-target-git-commit-url"]="https://github.com/${CI_VARS["pr-target-repo-name-full"]}/commit/${CI_VARS["pr-target-git-sha"]}"
          CI_VARS["pr-target-git-tag"]=""
        else
          # For non-PR events, null out PR-specific variables
          CI_VARS["pr-source-git-ref"]=""
          CI_VARS["pr-source-git-branch"]=""
          CI_VARS["pr-source-git-sha"]=""
          CI_VARS["pr-source-repo-name-full"]=""
          CI_VARS["pr-source-repo-owner"]=""
          CI_VARS["pr-source-repo-name"]=""
          CI_VARS["pr-source-is-fork"]=""
          CI_VARS["pr-source-git-branch-url"]=""
          CI_VARS["pr-source-git-commit-url"]=""
          CI_VARS["pr-target-git-ref"]=""
          CI_VARS["pr-target-git-branch"]=""
          CI_VARS["pr-target-git-sha"]=""
          CI_VARS["pr-target-repo-name-full"]=""
          CI_VARS["pr-target-repo-owner"]=""
          CI_VARS["pr-target-repo-name"]=""
          CI_VARS["pr-target-git-branch-url"]=""
          CI_VARS["pr-target-git-commit-url"]=""
          CI_VARS["pr-target-git-tag"]=""
        fi
        
        # Auto-detect workflow_dispatch inputs and update variables accordingly
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          echo "Detecting workflow_dispatch inputs..."
          
          # Auto-detect PR input (pr or pr-number)
          pr_input="${{ github.event.inputs.pr || github.event.inputs.pr-number }}"
          if [[ -n "$pr_input" ]]; then
            # Validate PR input to prevent command injection
            if [[ "$pr_input" =~ ^[0-9]+$ ]] || [[ "$pr_input" =~ ^https://github\.com/[^/]+/[^/]+/pull/[0-9]+$ ]]; then
              echo "Auto-detected PR input: $pr_input"
              CI_VARS["pr-number"]="$pr_input"
              
              if [[ "${{ steps.check-gh-cli.outputs.gh-available }}" == "true" ]]; then
                # Fetch PR data and update resolved variables to point to PR head
                pr_data=$(gh pr view "$pr_input" --json headRefName,headRepository,headRepositoryOwner,number,title 2>/dev/null || echo "")
                if [[ -n "$pr_data" ]]; then
                  source_branch=$(echo "$pr_data" | jq -r '.headRefName // empty')
                  source_repo=$(echo "$pr_data" | jq -r '.headRepository.nameWithOwner // empty')
                  source_owner=$(echo "$pr_data" | jq -r '.headRepositoryOwner.login // empty')
                  source_repo_name=$(echo "$pr_data" | jq -r '.headRepository.name // empty')
                  pr_title=$(echo "$pr_data" | jq -r '.title // empty')
                  
                  if [[ -n "$source_branch" ]]; then
                    # Update resolved variables to point to PR head
                    CI_VARS["resolved-git-ref"]="refs/heads/$source_branch"
                    CI_VARS["resolved-git-branch"]="$source_branch"
                    CI_VARS["resolved-repo-name-full"]="$source_repo"
                    CI_VARS["resolved-repo-owner"]="$source_owner"
                    CI_VARS["resolved-repo-name"]="$source_repo_name"
                    CI_VARS["resolved-git-branch-url"]="https://github.com/$source_repo/tree/$source_branch"
                    CI_VARS["pr-title"]="$pr_title"
                    CI_VARS["pr-url"]="https://github.com/${{ github.repository }}/pull/$pr_input"
                    CI_VARS["is-pr"]="true"
                  fi
                fi
              fi
            else
              echo "Error: Invalid PR input '$pr_input'. Must be a PR number or valid PR URL." >&2
            fi
          fi
          
          # Auto-detect comment-id input
          comment_id_input="${{ github.event.inputs.comment-id }}"
          if [[ -n "$comment_id_input" ]]; then
            echo "Auto-detected comment-id input: $comment_id_input"
            CI_VARS["comment-id"]="$comment_id_input"
          fi
          
          # Auto-detect issue input (issue-id or issue-number)
          issue_input="${{ github.event.inputs.issue-id || github.event.inputs.issue-number }}"
          if [[ -n "$issue_input" ]]; then
            echo "Auto-detected issue input: $issue_input"
            CI_VARS["issue-number"]="$issue_input"
            # If we have both issue and comment, construct comment URL
            if [[ -n "$comment_id_input" && -n "$issue_input" ]]; then
              CI_VARS["comment-url"]="https://github.com/${{ github.repository }}/issues/$issue_input#issuecomment-$comment_id_input"
            fi
          fi
        fi
        
        # PR Variables
        CI_VARS["pr-number"]="${{ github.event.pull_request.number || github.event.issue.number }}"
        CI_VARS["pr-title"]="${{ github.event.pull_request.title }}"
        if [[ -n "${{ github.event.pull_request.number }}" ]]; then
          CI_VARS["pr-url"]="https://github.com/${{ github.repository }}/pull/${{ github.event.pull_request.number }}"
        else
          CI_VARS["pr-url"]=""
        fi
        
        # Comment Variables
        CI_VARS["comment-id"]="${{ github.event.comment.id }}"
        if [[ -n "${{ github.event.comment.id }}" ]]; then
          CI_VARS["comment-url"]="https://github.com/${{ github.repository }}/issues/${{ github.event.issue.number || github.event.pull_request.number }}#issuecomment-${{ github.event.comment.id }}"
        else
          CI_VARS["comment-url"]=""
        fi
        
        # Additional Resolved Metadata
        CI_VARS["run-id"]="${{ github.run_id }}"
        CI_VARS["run-url"]="https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
        
        # Boolean: whether current context is a PR
        if [[ "${{ github.event_name }}" == "pull_request" || "${{ github.event_name }}" == "pull_request_target" ]]; then
          CI_VARS["is-pr"]="true"
        else
          CI_VARS["is-pr"]="false"
        fi
        
        # Output each CI variable that has a value
        for var_name in "${!CI_VARS[@]}"; do
          var_value="${CI_VARS[$var_name]}"
          if [[ -n "$var_value" && "$var_value" != "null" && "$var_value" != "" ]]; then
            echo "$var_name=$var_value" >> "$GITHUB_OUTPUT"
            echo "Resolved CI variable: $var_name = $var_value"
          else
            echo "$var_name=" >> "$GITHUB_OUTPUT"
            echo "Resolved CI variable: $var_name = (empty)"
          fi
        done
        
        # Store CI variables for merge step
        ci_vars_json="{}"
        for var_name in "${!CI_VARS[@]}"; do
          var_value="${CI_VARS[$var_name]}"
          if [[ -n "$var_value" && "$var_value" != "null" && "$var_value" != "" ]]; then
            ci_vars_json=$(echo "$ci_vars_json" | jq --arg key "$var_name" --arg value "$var_value" '. + {($key): $value}')
          fi
        done
        # Make JSON compact for GITHUB_ENV
        ci_vars_json_compact=$(echo "$ci_vars_json" | jq -c .)
        echo "CI_VARS_JSON=$ci_vars_json_compact" >> "$GITHUB_ENV"

    # Process Jinja inputs using external action if jinja_inputs provided
    - id: process-jinja
      if: ${{ inputs.jinja_inputs != '' }}
      shell: bash
      run: |
        # Create Jinja template to process jinja_inputs
        > "$TEMP_JINJA_TEMPLATE"  # Clear the file first

        echo "=== Jinja inputs data ==="
        echo '${{ inputs.jinja_inputs }}'
        echo "=== Jinja inputs data ==="

        while IFS= read -r line; do
          # Debug: Show what line we're processing
          echo "DEBUG: Processing line: '$line'"

          # Skip empty lines and comments
          [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

          # Split on first = character
          if [[ "$line" =~ ^([^=]+)=(.*)$ ]]; then
            var_name="${BASH_REMATCH[1]}"
            expression="${BASH_REMATCH[2]}"

            # Trim whitespace from variable name
            var_name=$(echo "$var_name" | xargs)

            # Append to template file - each line will be VAR_NAME={{ expression }}
            NEW_JINJA_LINE="${var_name}={{ ${expression} }}"
            # Debug: Show what we're about to write
            echo "DEBUG: Adding to template: ${NEW_JINJA_LINE}"

            echo "$NEW_JINJA_LINE" >> "$TEMP_JINJA_TEMPLATE"
          fi
        done <<< "${{ format('{0}{1}', inputs.jinja_inputs, '\n')  }}"
        # End file with newline
        echo "" >> "$TEMP_JINJA_TEMPLATE"

        # Debug: Print the template file contents
        echo "=== Generated Jinja template ==="
        cat "$TEMP_JINJA_TEMPLATE"
        echo "=== End template ==="

        # Create variables file with current context + jinja_inputs
        cat > "$TEMP_VARS_FILE" << VARS_EOF
        {
          "jinja_inputs": $(echo "$JINJA_INPUTS_DATA" | jq -Rs .)
        }
        VARS_EOF

        # Add existing resolved variables to the context
        if [[ -f "$TEMP_VARS_FILE" ]]; then
          # Merge with initial resolved vars if any exist
          echo "Using variables file: $TEMP_VARS_FILE"
        fi

    - id: render-jinja
      if: ${{ inputs.jinja_inputs != '' }}
      uses: lexty/jinja2-renderer@v1
      with:
        template_path: ${{ env.TEMP_JINJA_TEMPLATE }}
        output_path: ${{ env.TEMP_JINJA_OUTPUT }}
        variables_file: ${{ env.TEMP_VARS_FILE }}
        environment_variables: 'false'
        strict: 'false'

    - id: merge-results
      shell: bash
      run: |
        declare -A RESOLVED_VARS

        # Re-load static variables
        if [[ -n "${{ inputs.static_inputs }}" ]]; then
          while IFS= read -r line; do
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
            if [[ "$line" =~ ^([^=]+)=(.*)$ ]]; then
              var_name="${BASH_REMATCH[1]}"
              var_value="${BASH_REMATCH[2]}"
              var_name=$(echo "$var_name" | xargs)
              RESOLVED_VARS["$var_name"]="$var_value"
            fi
          done <<< "${{ inputs.static_inputs }}"
        fi

        # Add CI variables to RESOLVED_VARS
        if [[ -n "$CI_VARS_JSON" ]]; then
          echo "Adding standard CI variables..."
          # Parse CI_VARS_JSON and add to RESOLVED_VARS
          while IFS="=" read -r key value; do
            if [[ -n "$key" && -n "$value" ]]; then
              RESOLVED_VARS["$key"]="$value"
              echo "Added CI variable: $key = $value"
              # Also output as individual GitHub Action output
              echo "$key=$value" >> "$GITHUB_OUTPUT"
            fi
          done < <(echo "$CI_VARS_JSON" | jq -r 'to_entries[] | "\(.key)=\(.value)"' 2>/dev/null || echo "")
        fi

        # Process jinja results if they exist
        if [[ -f "$TEMP_JINJA_OUTPUT" ]]; then
          echo "=== Jinja output file contents ==="
          cat "$TEMP_JINJA_OUTPUT"
          echo "=== End Jinja output ==="

          echo "Processing Jinja results..."
          while IFS= read -r line; do
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
            if [[ "$line" =~ ^([^=]+)=(.*)$ ]]; then
              var_name="${BASH_REMATCH[1]}"
              var_value="${BASH_REMATCH[2]}"
              var_name=$(echo "$var_name" | xargs)
              echo "Found resolved Jinja variable: $var_name = $var_value"
              RESOLVED_VARS["$var_name"]="$var_value"
              echo "$var_name=$var_value" >> "$GITHUB_OUTPUT"
            fi
          done < "$TEMP_JINJA_OUTPUT"

          # Clean up temp files
          rm -f "$TEMP_VARS_FILE" "$TEMP_JINJA_TEMPLATE" "$TEMP_JINJA_OUTPUT"
        fi

        # Build final JSON object with all resolved variables using jq
        json_payload="{}"
        for var_name in "${!RESOLVED_VARS[@]}"; do
          json_payload=$(echo "$json_payload" | jq --arg key "$var_name" --arg value "${RESOLVED_VARS[$var_name]}" '. + {($key): $value}')
        done

        # Make JSON compact for GITHUB_OUTPUT
        json_payload_compact=$(echo "$json_payload" | jq -c .)
        # Output the JSON object as 'custom'
        echo "custom=$json_payload_compact" >> "$GITHUB_OUTPUT"

        # Logging with GitHub Actions grouping for better scanability
        SHOULD_LOG="${{ inputs.log_outputs == 'true' || inputs.non_sensitive == 'true' }}"
        if [[ "$SHOULD_LOG" == "true" ]]; then
          echo "::group::🔧 Variable Resolution Results"
          echo "✅ Resolved variables:"
          for var_name in "${!RESOLVED_VARS[@]}"; do
            echo "  📝 $var_name: ${RESOLVED_VARS[$var_name]}"
          done
          echo "  📦 custom (JSON): $json_payload_compact"
          echo "::endgroup::"

          {
            echo "### 🔍 Variable Resolution Summary"
            for var_name in "${!RESOLVED_VARS[@]}"; do
              echo "- 📝 \`$var_name\`: ${RESOLVED_VARS[$var_name]}"
            done
            echo "- 📦 \`custom\`: $json_payload_compact"
          } >> "$GITHUB_STEP_SUMMARY"
        fi
