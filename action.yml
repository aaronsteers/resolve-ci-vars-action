name: Resolve Vars
description: |
  Resolve variables using a combination of (1) pre-built resolutions, (2) static inputs, and (3) Jinja2 expressions.
inputs:
  static_inputs:
    description: >
      Variable assignments in key=value format (multiline string).
      Each line should be in the format: variable_name=value
  jinja_inputs:
    description: >
      Jinja2 expression to evaluate (e.g. user or default_user)
    required: false
  log_outputs:
    description: >
      Whether to log the resolved value (default false). This can be enabled if
      inputs and outputs are non-sensitive. you can also use this for sensitive
      values IIF you are confident you have masked sensitive values using
      GitHub secret masking.
    default: 'false'
    required: false
  non_sensitive:
    description: >
      Alias for log_outputs (true = show evaluated output)
    default: 'false'
    required: false
outputs:
  all:
    value: ${{ steps.merge-results.outputs.all_vars }}
    description: 'JSON-encoded object with all resolved values'
  # Repository Context
  repo:
    value: ${{ steps.merge-results.outputs.repo }}
    description: 'Target repository (base repo in owner/name format)'
  target-repo:
    value: ${{ steps.merge-results.outputs.target-repo }}
    description: 'Target repository (base repo in owner/name format)'
  repo-owner:
    value: ${{ steps.merge-results.outputs.repo-owner }}
    description: 'Repository owner/organization'
  repo-name:
    value: ${{ steps.merge-results.outputs.repo-name }}
    description: 'Repository name only'
  repo-name-full:
    value: ${{ steps.merge-results.outputs.repo-name-full }}
    description: 'Full repository name (owner/name)'
  # Branch Context
  source-branch:
    value: ${{ steps.merge-results.outputs.source-branch }}
    description: 'Source branch being merged (null for issues)'
  target-branch:
    value: ${{ steps.merge-results.outputs.target-branch }}
    description: 'Target branch for merge (null for issues)'
  source-repo:
    value: ${{ steps.merge-results.outputs.source-repo }}
    description: 'Source repository (important for forks, null for issues)'
  # SHA Context
  source-sha:
    value: ${{ steps.merge-results.outputs.source-sha }}
    description: 'Source commit SHA (null for issues)'
  target-sha:
    value: ${{ steps.merge-results.outputs.target-sha }}
    description: 'Target commit SHA (null for issues)'
  restricted-security-mode:
    value: ${{ steps.merge-results.outputs.restricted-security-mode }}
    description: 'Whether running in restricted security mode (fork/dependabot pull_request)'
  # Pull Request Context
  pr-number:
    value: ${{ steps.merge-results.outputs.pr-number }}
    description: 'Pull request number'
  pr-title:
    value: ${{ steps.merge-results.outputs.pr-title }}
    description: 'Pull request title'
  pr-author:
    value: ${{ steps.merge-results.outputs.pr-author }}
    description: 'Pull request author username'
  pr-draft:
    value: ${{ steps.merge-results.outputs.pr-draft }}
    description: 'Whether PR is draft'
  pr-from-fork:
    value: ${{ steps.merge-results.outputs.pr-from-fork }}
    description: 'Whether PR is from a fork'
  # Issue Context
  issue-number:
    value: ${{ steps.merge-results.outputs.issue-number }}
    description: 'Issue number (equals pr-number for PRs)'
  issue-title:
    value: ${{ steps.merge-results.outputs.issue-title }}
    description: 'Issue title'
  issue-author:
    value: ${{ steps.merge-results.outputs.issue-author }}
    description: 'Issue author username'
  issue-type:
    value: ${{ steps.merge-results.outputs.issue-type }}
    description: 'Type of issue context (pull_request or issue)'
  # Comment Context
  comment-id:
    value: ${{ steps.merge-results.outputs.comment-id }}
    description: 'Comment ID that triggered workflow'
  comment-author:
    value: ${{ steps.merge-results.outputs.comment-author }}
    description: 'Comment author username'
  comment-body:
    value: ${{ steps.merge-results.outputs.comment-body }}
    description: 'Comment body text'
  # Workflow Context
  trigger-type:
    value: ${{ steps.merge-results.outputs.trigger-type }}
    description: 'Event that triggered workflow'
  actor:
    value: ${{ steps.merge-results.outputs.actor }}
    description: 'User who triggered the workflow'
  run-id:
    value: ${{ steps.merge-results.outputs.run-id }}
    description: 'Workflow run ID'
  run-number:
    value: ${{ steps.merge-results.outputs.run-number }}
    description: 'Workflow run number'
  # Legacy outputs
  var1:
    value: ${{ steps.merge-results.outputs.var1 }}
    description: 'Custom user-defined output variable 1'
  var2:
    value: ${{ steps.merge-results.outputs.var2 }}
    description: 'Custom user-defined output variable 2'
  var3:
    value: ${{ steps.merge-results.outputs.var3 }}
    description: 'Custom user-defined output variable 3'
runs:
  using: "composite"
  steps:
    - id: resolve
      shell: bash
      run: |
        declare -A RESOLVED_VARS

        # Process static_inputs
        if [[ -n "${{ inputs.static_inputs }}" ]]; then
          echo "Processing static inputs..."

          # Read the multiline input and process each line
          while IFS= read -r line; do
            # Skip empty lines and comments
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

            # Split on first = character
            if [[ "$line" =~ ^([^=]+)=(.*)$ ]]; then
              var_name="${BASH_REMATCH[1]}"
              var_value="${BASH_REMATCH[2]}"

              # Trim whitespace from variable name
              var_name=$(echo "$var_name" | xargs)

              echo "Found variable: $var_name = $var_value"

              # Store in associative array
              RESOLVED_VARS["$var_name"]="$var_value"

              # Output each variable as individual output
              echo "$var_name=$var_value" >> "$GITHUB_OUTPUT"
            fi
          done <<< "${{ inputs.static_inputs }}"
        fi

        # Process jinja_inputs if provided
        if [[ -n "${{ inputs.jinja_inputs }}" ]]; then
          echo "Processing Jinja inputs..."

          # Create temporary files in the workspace (accessible to Docker containers)
          temp_vars_file="$GITHUB_WORKSPACE/.temp_vars.json"
          temp_jinja_template="$GITHUB_WORKSPACE/.temp_template.j2"
          temp_jinja_output="$GITHUB_WORKSPACE/.temp_output.txt"

          # Write current resolved variables to JSON file
          echo "{" > "$temp_vars_file"
          first=true
          for var_name in "${!RESOLVED_VARS[@]}"; do
            if [[ "$first" == "true" ]]; then
              first=false
            else
              echo "," >> "$temp_vars_file"
            fi
            # Escape quotes in the value for JSON
            escaped_value=$(printf '%s\n' "${RESOLVED_VARS[$var_name]}" | sed 's/"/\\"/g')
            echo -n "  \"$var_name\": \"$escaped_value\"" >> "$temp_vars_file"
          done
          echo "" >> "$temp_vars_file"
          echo "}" >> "$temp_vars_file"

          # Save jinja_inputs and temp files to environment for next step
          # Set environment variables for the jinja renderer
          echo "TEMP_VARS_FILE=$temp_vars_file" >> "$GITHUB_ENV"
          echo "TEMP_JINJA_TEMPLATE=$temp_jinja_template" >> "$GITHUB_ENV"
          echo "TEMP_JINJA_OUTPUT=$temp_jinja_output" >> "$GITHUB_ENV"
        fi

        # Create initial JSON with static variables
        json_payload="{"
        first=true
        for var_name in "${!RESOLVED_VARS[@]}"; do
          if [[ "$first" == "true" ]]; then
            first=false
          else
            json_payload+=","
          fi
          # Escape quotes in the value
          escaped_value=$(printf '%s\n' "${RESOLVED_VARS[$var_name]}" | sed 's/"/\\"/g')
          json_payload+="\"$var_name\":\"$escaped_value\""
        done
        json_payload+="}"

        # Save initial JSON for potential jinja processing
        echo "INITIAL_JSON=$json_payload" >> "$GITHUB_ENV"

    # Process standard CI variables
    - id: resolve-standard-ci-vars
      shell: bash
      run: |
        declare -A CI_VARS
        
        # Repository & Git Context
        CI_VARS["repo"]="${{ github.event.pull_request.base.repo.full_name || github.repository }}"
        CI_VARS["target-repo"]="${{ github.event.pull_request.base.repo.full_name || github.repository }}"
        CI_VARS["repo-owner"]="${{ github.repository_owner }}"
        repo_name="${{ github.event.repository.name }}"
        if [[ -z "$repo_name" ]]; then
          repo_full="${{ github.repository }}"
          repo_name="${repo_full##*/}"
        fi
        CI_VARS["repo-name"]="$repo_name"
        CI_VARS["repo-name-full"]="${{ github.event.pull_request.base.repo.full_name || github.repository }}"
        
        # Git refs - only populate for PR events, null for issue events and workflow_dispatch without pr input
        if [[ "${{ github.event_name }}" == "pull_request" || "${{ github.event_name }}" == "pull_request_target" ]]; then
          CI_VARS["source-branch"]="${{ github.head_ref || github.ref_name }}"
          CI_VARS["target-branch"]="${{ github.base_ref || github.event.repository.default_branch || 'main' }}"
          CI_VARS["source-repo"]="${{ github.event.pull_request.head.repo.full_name || github.repository }}"
          CI_VARS["source-sha"]="${{ github.event.pull_request.head.sha || github.sha }}"
          CI_VARS["target-sha"]="${{ github.event.pull_request.base.sha }}"
        elif [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ inputs.pr }}" ]]; then
          # For workflow_dispatch with pr input, we can populate some refs but need to fetch PR data
          CI_VARS["source-branch"]="${{ github.ref_name }}"
          CI_VARS["target-branch"]="${{ github.event.repository.default_branch || 'main' }}"
          CI_VARS["source-repo"]="${{ github.repository }}"
          CI_VARS["source-sha"]="${{ github.sha }}"
          CI_VARS["target-sha"]=""
        elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          # For workflow_dispatch without pr input, set both source-branch and target-branch to current branch
          CI_VARS["source-branch"]="${{ github.ref_name }}"
          CI_VARS["target-branch"]="${{ github.ref_name }}"
          CI_VARS["source-repo"]="${{ github.repository }}"
          CI_VARS["source-sha"]="${{ github.sha }}"
          CI_VARS["target-sha"]="${{ github.sha }}"
        else
          # For issue events, null out git refs since issues don't have branches
          CI_VARS["source-branch"]=""
          CI_VARS["target-branch"]=""
          CI_VARS["source-repo"]=""
          CI_VARS["source-sha"]=""
          CI_VARS["target-sha"]=""
        fi
        
        # Smart source-branch resolution for workflow_dispatch with PR input
        if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ inputs.pr }}" ]]; then
          # Validate PR input to prevent command injection
          pr_input="${{ inputs.pr }}"
          if [[ "$pr_input" =~ ^[0-9]+$ ]] || [[ "$pr_input" =~ ^https://github\.com/[^/]+/[^/]+/pull/[0-9]+$ ]]; then
            echo "Resolving source-branch for PR $pr_input..."
            if command -v gh >/dev/null 2>&1; then
              source_branch=$(gh pr view "$pr_input" --json headRefName --jq '.headRefName' 2>/dev/null || echo "")
              if [[ -n "$source_branch" ]]; then
                CI_VARS["source-branch"]="$source_branch"
                # Also update source-repo to match the PR's head repo for consistency
                source_repo=$(gh pr view "$pr_input" --json headRepository --jq '.headRepository.nameWithOwner' 2>/dev/null || echo "")
                if [[ -n "$source_repo" ]]; then
                  CI_VARS["source-repo"]="$source_repo"
                fi
              else
                CI_VARS["source-branch"]="${{ github.ref_name }}"
              fi
            else
              CI_VARS["source-branch"]="${{ github.ref_name }}"
            fi
          else
            echo "Error: Invalid PR input '$pr_input'. Must be a PR number or valid PR URL." >&2
            CI_VARS["source-branch"]="${{ github.ref_name }}"
          fi
        fi
        
        # Pull Request Variables
        CI_VARS["pr-number"]="${{ github.event.pull_request.number || github.event.issue.number }}"
        CI_VARS["pr-title"]="${{ github.event.pull_request.title }}"
        CI_VARS["pr-author"]="${{ github.event.pull_request.user.login }}"
        CI_VARS["pr-draft"]="${{ github.event.pull_request.draft }}"
        CI_VARS["pr-from-fork"]="${{ github.event.pull_request.head.repo.fork }}"
        
        # Issue Variables  
        CI_VARS["issue-number"]="${{ github.event.issue.number || github.event.pull_request.number }}"
        CI_VARS["issue-title"]="${{ github.event.issue.title || github.event.pull_request.title }}"
        CI_VARS["issue-author"]="${{ github.event.issue.user.login || github.event.pull_request.user.login }}"
        CI_VARS["issue-type"]="${{ github.event.pull_request && 'pull_request' || 'issue' }}"
        
        # Comment Variables
        CI_VARS["comment-id"]="${{ github.event.comment.id }}"
        CI_VARS["comment-author"]="${{ github.event.comment.user.login }}"
        CI_VARS["comment-body"]="${{ github.event.comment.body }}"
        
        # Workflow Context
        CI_VARS["trigger-type"]="${{ github.event_name }}"
        CI_VARS["actor"]="${{ github.actor }}"
        CI_VARS["run-id"]="${{ github.run_id }}"
        CI_VARS["run-number"]="${{ github.run_number }}"
        
        # Security Context
        # restricted-security-mode is true when running from fork/dependabot and trigger is pull_request
        if [[ "${{ github.event_name }}" == "pull_request" && ("${{ github.event.pull_request.head.repo.fork }}" == "true" || "${{ github.actor }}" == "dependabot[bot]") ]]; then
          CI_VARS["restricted-security-mode"]="true"
        else
          CI_VARS["restricted-security-mode"]="false"
        fi
        
        # Output each CI variable that has a value
        for var_name in "${!CI_VARS[@]}"; do
          var_value="${CI_VARS[$var_name]}"
          if [[ -n "$var_value" && "$var_value" != "null" && "$var_value" != "" ]]; then
            echo "$var_name=$var_value" >> "$GITHUB_OUTPUT"
            echo "Resolved CI variable: $var_name = $var_value"
          else
            echo "$var_name=" >> "$GITHUB_OUTPUT"
            echo "Resolved CI variable: $var_name = (empty)"
          fi
        done
        
        # Store CI variables for merge step
        ci_vars_json="{"
        first=true
        for var_name in "${!CI_VARS[@]}"; do
          var_value="${CI_VARS[$var_name]}"
          if [[ -n "$var_value" && "$var_value" != "null" && "$var_value" != "" ]]; then
            if [[ "$first" == "true" ]]; then
              first=false
            else
              ci_vars_json+=","
            fi
            # Escape quotes in the value for JSON
            escaped_value=$(printf '%s\n' "$var_value" | sed 's/"/\\"/g')
            ci_vars_json+="\"$var_name\":\"$escaped_value\""
          fi
        done
        ci_vars_json+="}"
        echo "CI_VARS_JSON=$ci_vars_json" >> "$GITHUB_ENV"

    # Process Jinja inputs using external action if jinja_inputs provided
    - id: process-jinja
      if: ${{ inputs.jinja_inputs != '' }}
      shell: bash
      run: |
        # Create Jinja template to process jinja_inputs
        > "$TEMP_JINJA_TEMPLATE"  # Clear the file first

        echo "=== Jinja inputs data ==="
        echo '${{ inputs.jinja_inputs }}'
        echo "=== Jinja inputs data ==="

        while IFS= read -r line; do
          # Debug: Show what line we're processing
          echo "DEBUG: Processing line: '$line'"

          # Skip empty lines and comments
          [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

          # Split on first = character
          if [[ "$line" =~ ^([^=]+)=(.*)$ ]]; then
            var_name="${BASH_REMATCH[1]}"
            expression="${BASH_REMATCH[2]}"

            # Trim whitespace from variable name
            var_name=$(echo "$var_name" | xargs)

            # Append to template file - each line will be VAR_NAME={{ expression }}
            NEW_JINJA_LINE="${var_name}={{ ${expression} }}"
            # Debug: Show what we're about to write
            echo "DEBUG: Adding to template: ${NEW_JINJA_LINE}"

            echo "$NEW_JINJA_LINE" >> "$TEMP_JINJA_TEMPLATE"
          fi
        done <<< "${{ format('{0}{1}', inputs.jinja_inputs, '\n')  }}"
        # End file with newline
        echo "" >> "$TEMP_JINJA_TEMPLATE"

        # Debug: Print the template file contents
        echo "=== Generated Jinja template ==="
        cat "$TEMP_JINJA_TEMPLATE"
        echo "=== End template ==="

        # Create variables file with current context + jinja_inputs
        cat > "$TEMP_VARS_FILE" << VARS_EOF
        {
          "jinja_inputs": $(echo "$JINJA_INPUTS_DATA" | jq -Rs .)
        }
        VARS_EOF

        # Add existing resolved variables to the context
        if [[ -f "$TEMP_VARS_FILE" ]]; then
          # Merge with initial resolved vars if any exist
          echo "Using variables file: $TEMP_VARS_FILE"
        fi

    - id: render-jinja
      if: ${{ inputs.jinja_inputs != '' }}
      uses: lexty/jinja2-renderer@v1
      with:
        template_path: ${{ env.TEMP_JINJA_TEMPLATE }}
        output_path: ${{ env.TEMP_JINJA_OUTPUT }}
        variables_file: ${{ env.TEMP_VARS_FILE }}
        environment_variables: 'false'
        strict: 'false'

    - id: merge-results
      shell: bash
      run: |
        declare -A RESOLVED_VARS

        # Re-load static variables
        if [[ -n "${{ inputs.static_inputs }}" ]]; then
          while IFS= read -r line; do
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
            if [[ "$line" =~ ^([^=]+)=(.*)$ ]]; then
              var_name="${BASH_REMATCH[1]}"
              var_value="${BASH_REMATCH[2]}"
              var_name=$(echo "$var_name" | xargs)
              RESOLVED_VARS["$var_name"]="$var_value"
            fi
          done <<< "${{ inputs.static_inputs }}"
        fi

        # Add CI variables to RESOLVED_VARS
        if [[ -n "$CI_VARS_JSON" ]]; then
          echo "Adding standard CI variables..."
          # Parse CI_VARS_JSON and add to RESOLVED_VARS
          while IFS="=" read -r key value; do
            if [[ -n "$key" && -n "$value" ]]; then
              RESOLVED_VARS["$key"]="$value"
              echo "Added CI variable: $key = $value"
              # Also output as individual GitHub Action output
              echo "$key=$value" >> "$GITHUB_OUTPUT"
            fi
          done < <(echo "$CI_VARS_JSON" | jq -r 'to_entries[] | "\(.key)=\(.value)"' 2>/dev/null || echo "")
        fi

        # Process jinja results if they exist
        if [[ -f "$TEMP_JINJA_OUTPUT" ]]; then
          echo "=== Jinja output file contents ==="
          cat "$TEMP_JINJA_OUTPUT"
          echo "=== End Jinja output ==="

          echo "Processing Jinja results..."
          while IFS= read -r line; do
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
            if [[ "$line" =~ ^([^=]+)=(.*)$ ]]; then
              var_name="${BASH_REMATCH[1]}"
              var_value="${BASH_REMATCH[2]}"
              var_name=$(echo "$var_name" | xargs)
              echo "Found resolved Jinja variable: $var_name = $var_value"
              RESOLVED_VARS["$var_name"]="$var_value"
              echo "$var_name=$var_value" >> "$GITHUB_OUTPUT"
            fi
          done < "$TEMP_JINJA_OUTPUT"

          # Clean up temp files
          rm -f "$TEMP_VARS_FILE" "$TEMP_JINJA_TEMPLATE" "$TEMP_JINJA_OUTPUT"
        fi

        # Build final JSON object with all resolved variables
        json_payload="{"
        first=true
        for var_name in "${!RESOLVED_VARS[@]}"; do
          if [[ "$first" == "true" ]]; then
            first=false
          else
            json_payload+=","
          fi
          # Escape quotes in the value
          escaped_value=$(printf '%s\n' "${RESOLVED_VARS[$var_name]}" | sed 's/"/\\"/g')
          json_payload+="\"$var_name\":\"$escaped_value\""
        done
        json_payload+="}"

        # Output the JSON object as 'all_vars'
        echo "all_vars=$json_payload" >> "$GITHUB_OUTPUT"

        # Logging
        SHOULD_LOG="${{ inputs.log_outputs == 'true' || inputs.non_sensitive == 'true' }}"
        if [[ "$SHOULD_LOG" == "true" ]]; then
          echo "✅ Resolved variables:"
          for var_name in "${!RESOLVED_VARS[@]}"; do
            echo "  $var_name: ${RESOLVED_VARS[$var_name]}"
          done
          echo "  all_vars (JSON): $json_payload"

          {
            echo "### 🔍 Variable Resolution Summary"
            for var_name in "${!RESOLVED_VARS[@]}"; do
              echo "- \`$var_name\`: ${RESOLVED_VARS[$var_name]}"
            done
            echo "- \`all_vars\`: $json_payload"
          } >> "$GITHUB_STEP_SUMMARY"
        fi
