name: Resolve CI Vars
branding:
  icon: list
  color: blue
description: |
  Resolve variables using a combination of (1) pre-built resolutions, (2) static inputs, and (3) Jinja2 expressions.
inputs:
  static_inputs:
    description: >
      Variable assignments in key=value format (multiline string).
      Each line should be in the format: variable_name=value
  jinja_inputs:
    description: >
      Jinja2 expression to evaluate (e.g. user or default_user)
    required: false
  repo:
    description: >
      Optional. Target repository to resolve variables for (e.g. `myorg/my-repo``).
      If not provided, will use the current repository (github.repository)
      This is useful for resolving variables in a different repo than the one
      triggering the workflow.
      If it recommended to leave this omitted unless you are specifically doing
      cross-repo workflows.
    required: false
    default: ''
  pr:
    description: >
      Optional. PR number to resolve variables for (overrides auto-detection from workflow_dispatch inputs).
    required: false
    default: ''
  comment_id:
    description: >
      Optional. Comment ID to resolve variables for (overrides auto-detection
      from workflow_dispatch inputs). If not provided, can be automatically
      detected from a 'comment-id' workflow input, or the 'comment' github
      context.
    required: false
    default: ''
  log_outputs:
    description: >
      Whether to log the resolved value (default false). This can be enabled if
      inputs and outputs are non-sensitive. you can also use this for sensitive
      values IIF you are confident you have masked sensitive values using
      GitHub secret masking.
    default: 'false'
    required: false
  non_sensitive:
    description: >
      Alias for log_outputs (true = show evaluated output)
    default: 'false'
    required: false
outputs:
  custom:
    value: ${{ steps.merge-results.outputs.custom }}
    description: 'JSON-encoded object with all resolved values'
  # Resolved Variables (always the effective context)
  resolved-git-ref:
    value: ${{ steps.merge-results.outputs.resolved-git-ref }}
    description: 'Full Git ref (refs/heads/... or refs/tags/...)'
  resolved-git-branch:
    value: ${{ steps.merge-results.outputs.resolved-git-branch }}
    description: 'Short branch name (e.g. main, feature/foo)'
  resolved-git-sha:
    value: ${{ steps.merge-results.outputs.resolved-git-sha }}
    description: 'Commit SHA'
  resolved-git-tag:
    value: ${{ steps.merge-results.outputs.resolved-git-tag }}
    description: 'Tag name (if applicable)'
  resolved-repo-name:
    value: ${{ steps.merge-results.outputs.resolved-repo-name }}
    description: 'Repository name (e.g. my-repo)'
  resolved-repo-owner:
    value: ${{ steps.merge-results.outputs.resolved-repo-owner }}
    description: 'Repository owner (user or org)'
  resolved-repo-name-full:
    value: ${{ steps.merge-results.outputs.resolved-repo-name-full }}
    description: 'Owner + name (e.g. myorg/my-repo)'
  # PR Source Variables
  pr-source-git-ref:
    value: ${{ steps.merge-results.outputs.pr-source-git-ref }}
    description: 'Git ref of the source (PR head)'
  pr-source-git-branch:
    value: ${{ steps.merge-results.outputs.pr-source-git-branch }}
    description: 'Branch name of the source'
  pr-source-git-sha:
    value: ${{ steps.merge-results.outputs.pr-source-git-sha }}
    description: 'SHA of the source commit'
  pr-source-repo-name:
    value: ${{ steps.merge-results.outputs.pr-source-repo-name }}
    description: 'Source repo name'
  pr-source-repo-owner:
    value: ${{ steps.merge-results.outputs.pr-source-repo-owner }}
    description: 'Source repo owner'
  pr-source-repo-name-full:
    value: ${{ steps.merge-results.outputs.pr-source-repo-name-full }}
    description: 'Full source repo name (owner/name)'
  pr-source-repo-is-fork:
    value: ${{ steps.merge-results.outputs.pr-source-repo-is-fork }}
    description: 'Whether the source repo is a fork of the target repo'
  # PR Target Variables
  pr-target-git-ref:
    value: ${{ steps.merge-results.outputs.pr-target-git-ref }}
    description: 'Git ref of the target (PR base)'
  pr-target-git-branch:
    value: ${{ steps.merge-results.outputs.pr-target-git-branch }}
    description: 'Branch name of the target'
  pr-target-git-sha:
    value: ${{ steps.merge-results.outputs.pr-target-git-sha }}
    description: 'SHA of the target commit'
  pr-target-git-tag:
    value: ${{ steps.merge-results.outputs.pr-target-git-tag }}
    description: 'Tag name, if PR targets a tag'
  pr-target-repo-name:
    value: ${{ steps.merge-results.outputs.pr-target-repo-name }}
    description: 'Target repo name'
  pr-target-repo-owner:
    value: ${{ steps.merge-results.outputs.pr-target-repo-owner }}
    description: 'Target repo owner'
  pr-target-repo-name-full:
    value: ${{ steps.merge-results.outputs.pr-target-repo-name-full }}
    description: 'Full target repo name (owner/name)'
  # PR Variables
  pr-number:
    value: ${{ steps.merge-results.outputs.pr-number }}
    description: 'Pull request number (if applicable)'
  pr-url:
    value: ${{ steps.merge-results.outputs.pr-url }}
    description: 'URL to the pull request'
  pr-title:
    value: ${{ steps.merge-results.outputs.pr-title }}
    description: 'Title of the pull request'
  # Comment Variables
  comment-id:
    value: ${{ steps.merge-results.outputs.comment-id }}
    description: 'ID of the triggering comment (if applicable)'
  comment-url:
    value: ${{ steps.merge-results.outputs.comment-url }}
    description: 'URL to the triggering comment (if applicable)'
  # Additional Resolved Metadata
  run-id:
    value: ${{ steps.merge-results.outputs.run-id }}
    description: 'GitHub Actions run ID'
  run-url:
    value: ${{ steps.merge-results.outputs.run-url }}
    description: 'URL to the GitHub Actions run'
  is-pr:
    value: ${{ steps.merge-results.outputs.is-pr }}
    description: 'Boolean: whether the current context is a PR'
  # Legacy outputs
  var1:
    value: ${{ steps.merge-results.outputs.var1 }}
    description: 'Custom user-defined output variable 1'
  var2:
    value: ${{ steps.merge-results.outputs.var2 }}
    description: 'Custom user-defined output variable 2'
  var3:
    value: ${{ steps.merge-results.outputs.var3 }}
    description: 'Custom user-defined output variable 3'
runs:
  using: "composite"
  steps:
    - name: Check GitHub CLI availability
      id: check-gh-cli
      shell: bash
      run: |
        if command -v gh >/dev/null 2>&1; then
          echo "✅ The `gh` CLI was found!"
        else
          echo "Warning: GitHub CLI (gh) not available. PR resolution will be limited."
          exit 1
        fi

    - name: Resolve Target Repo
      id: resolve-target-repo
      shell: bash
      run: |
        # Check for explicit target repo input.
        # This will be used to locate comments and PRs if requested by number.
        # Comments and PRs are always resolved against the target repo, not the
        # source repo.
        target_repo_name_full=${{ inputs.repo || github.repository }}
        echo "target-repo-name-full=${target_repo_name_full}" >> "$GITHUB_OUTPUT"

    - name: Resolve Custom Variables
      id: resolve-custom-vars
      shell: bash
      run: |
        declare -A RESOLVED_VARS

        # Process static_inputs
        if [[ -n "${{ inputs.static_inputs }}" ]]; then
          echo "Processing static inputs..."

          # Read the multiline input and process each line
          while IFS= read -r line; do
            # Skip empty lines and comments
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

            # Split on first = character
            if [[ "$line" =~ ^([^=]+)=(.*)$ ]]; then
              var_name="${BASH_REMATCH[1]}"
              var_value="${BASH_REMATCH[2]}"

              # Trim whitespace from variable name
              var_name=$(echo "$var_name" | xargs)

              echo "Found variable: $var_name = $var_value"

              # Store in associative array
              RESOLVED_VARS["$var_name"]="$var_value"

              # Output each variable as individual output
              echo "$var_name=$var_value" >> "$GITHUB_OUTPUT"
            fi
          done <<< "${{ inputs.static_inputs }}"
        fi

        # Process jinja_inputs if provided
        if [[ -n "${{ inputs.jinja_inputs }}" ]]; then
          echo "Processing Jinja inputs..."

          # Create temporary files in the workspace (accessible to Docker containers)
          temp_vars_file="$GITHUB_WORKSPACE/.temp_vars.json"
          temp_jinja_template="$GITHUB_WORKSPACE/.temp_template.j2"
          temp_jinja_output="$GITHUB_WORKSPACE/.temp_output.txt"

          # Write current resolved variables to JSON file using jq
          json_vars="{}"
          for var_name in "${!RESOLVED_VARS[@]}"; do
            json_vars=$(echo "$json_vars" | jq --arg key "$var_name" --arg value "${RESOLVED_VARS[$var_name]}" '. + {($key): $value}')
          done
          echo "$json_vars" > "$temp_vars_file"

          # Save jinja_inputs and temp files to environment for next step
          # Set environment variables for the jinja renderer
          echo "TEMP_VARS_FILE=$temp_vars_file" >> "$GITHUB_ENV"
          echo "TEMP_JINJA_TEMPLATE=$temp_jinja_template" >> "$GITHUB_ENV"
          echo "TEMP_JINJA_OUTPUT=$temp_jinja_output" >> "$GITHUB_ENV"
        fi

        # Create initial JSON with static variables
        json_payload="{"
        first=true
        for var_name in "${!RESOLVED_VARS[@]}"; do
          if [[ "$first" == "true" ]]; then
            first=false
          else
            json_payload+=","
          fi
          # Properly escape the value for JSON using jq
          escaped_value=$(jq -R . <<< "${RESOLVED_VARS[$var_name]}")
          json_payload+="\"$var_name\":${escaped_value}"
        done
        json_payload+="}"

        # Save initial JSON for potential jinja processing
        echo "INITIAL_JSON=$json_payload" >> "$GITHUB_ENV"

    - name: Resolve Comment ID
      id: resolve-comment-id
      shell: bash
      run: |
        if [[ ! -z '${{ inputs.comment_id }}' ]]; then
          echo "ℹ️ Found comment ID from explicit input: ${{ inputs.comment_id }}"
          comment_id=${{ inputs.comment_id }}
        elif [[ ! -z '${{ inputs.comment-id }}' ]]; then
          echo "ℹ️ Found comment ID from comment event payload: ${{ inputs.comment-id }}"
          comment_id=${{ inputs.comment-id }}
        fi
        comment_id_input=${{ github.event.inputs.comment_id || github.event.inputs.comment-id }}
        if [[ ! -z "$comment_id_input" ]]; then
          echo "ℹ️ Found comment ID from workflow inputs: $comment_id_input"
          comment_id=$comment_id_input
        fi
        echo "comment-id=$comment_id" >> "$GITHUB_OUTPUT"
        target_repo_name_full="${{ steps.resolve-repo.outputs.target-repo-name-full }}"

        # Check the API to see if there's an attached PR to this comment
        if [[ -n "$comment_id" ]]; then
          echo "ℹ️ Checking API for attached PR to comment ID: $comment_id"
          # Simulate API call to check for PR
          pr_number=$(gh api repos/${target_repo_name_full}/issues/comments/$comment_id --jq '.pull_request.number // empty')
          if [[ -n "$pr_number" ]]; then
            echo "ℹ️ Found attached PR: $pr_number"
            echo "pr-number=$pr_number" >> "$GITHUB_OUTPUT"
          else
            echo "ℹ️ No attached PR found for comment ID: $comment_id"
          fi
        fi

    - name: Resolve PR Number
      id: resolve-pr-num
      shell: bash
      run: |
        # Method 1: Check for Explicit PR Input
        if [[ ! -z '${{ inputs.pr }}' ]]; then
          echo "Detected explicit PR input: ${{ inputs.pr }}"
          echo pr-number="${{ inputs.pr }}" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        # Method 2: Direct from GitHub event context
        if [[ "${{ github.event_name }}" == "pull_request" || "${{ github.event_name }}" == "pull_request_target" ]]; then
          pr_number="${{ github.event.pull_request.number }}"
          echo "Detected PR from event context: $pr_number"
          echo pr-number="$pr_number" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        # Method 3: Auto-detect from workflow_dispatch inputs
        if [[ -z "$pr_number" && "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          # Check various input field names for PR
          pr_input="${{ github.event.inputs.pr || github.event.inputs.pr-number }}"
          if [[ -n "$pr_input" ]]; then
            # Validate PR input to prevent command injection
            if [[ "$pr_input" =~ ^[0-9]+$ ]]; then
              pr_number="$pr_input"
              echo "Auto-detected PR from workflow_dispatch inputs: $pr_number"
              echo pr-number="$pr_number" >> "$GITHUB_OUTPUT"
              exit 0
            elif [[ "$pr_input" =~ ^https://github\.com/[a-zA-Z0-9._-]+/[a-zA-Z0-9._-]+/pull/([0-9]+)$ ]]; then
              pr_number="${BASH_REMATCH[1]}"
              echo "Auto-detected PR from URL in workflow_dispatch inputs: $pr_number"
              echo pr-number="$pr_number" >> "$GITHUB_OUTPUT"
              exit 0
            else
              echo "Error: Invalid PR input '$pr_input'. Must be a PR number or valid PR URL." >&2
              exit 1
            fi
          fi
        fi

        # Method 3: Issue comment events (could be on a PR)
        if [[ -z "$pr_number" && ! -z "${{ steps.resolve-comment-id.outputs.comment-id }}" ]]; then
          # Check if the issue is actually a pull request
          if [[ -n "${{ github.event.issue.pull_request.url }}" ]]; then
            pr_number="${{ github.event.issue.number }}"
            echo "Detected PR from issue comment event: $pr_number"
            echo "pr-number=$pr_number" >> "$GITHUB_OUTPUT"
            exit 0
          fi
        fi

        # Output the resolved PR number if found
        if [[ -n "$pr_number" ]]; then
          echo "pr-number=$pr_number" >> "$GITHUB_OUTPUT"
          echo "Resolved PR number: $pr_number"
          exit 0
        else
          echo "No PR detected in current context"
          echo "pr-number=" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        # 👀 Should not reach here.

    - name: Resolve Standard CI Variables
      id: resolve-standard-ci-vars
      shell: bash
      run: |
        declare -A CI_VARS

        # Easily Resolved Metadata
        target_repo_name_full="${{ steps.resolve-target-repo.outputs.target-repo-name-full }}"
        CI_VARS["run-id"]="${{ github.run_id }}"
        CI_VARS["run-url"]="https://github.com/${target_repo_name_full}/actions/runs/${{ github.run_id }}"

        pr_number="${{ steps.resolve-pr-num.outputs.pr-number }}"
        if [[ -z "$pr_number" ]]; then
          echo "Not in PR context"
          is_pr_context="false"
          CI_VARS["is-pr"]="false"

          CI_VARS["resolved-git-ref"]="${{ github.ref }}"
          CI_VARS["resolved-git-branch"]="${{ github.ref_name }}"
          CI_VARS["resolved-git-sha"]="${{ github.sha }}"
          CI_VARS["resolved-repo-name-full"]="${target_repo_name_full}"
          CI_VARS["resolved-repo-owner"]="${{ github.repository_owner }}"
          repo_name="${{ github.event.repository.name }}"
          if [[ -z "$repo_name" ]]; then
            repo_full="${target_repo_name_full}"
            repo_name="${repo_full##*/}"
          fi
          CI_VARS["resolved-repo-name"]="$repo_name"

          # Git tag (if applicable, ignored on PRs)
          if [[ "${{ github.ref }}" =~ ^refs/tags/ ]]; then
            CI_VARS["resolved-git-tag"]="${{ github.ref_name }}"
          else
            CI_VARS["resolved-git-tag"]=""
          fi

        else  # We're on a PR
          echo "Working with PR #$pr_number"
          is_pr_context="true"
          CI_VARS["is-pr"]="true"
          CI_VARS["pr-number"]="pr_number"

          # Fetch PR data using GitHub CLI
          pr_path="repos/${target_repo_name_full}/pulls/${pr_number}"
          echo "Fetching data for PR #${pr_number} using GitHub CLI ('$pr_path')..."
          pr_data=$(gh api "$pr_path" 2>/dev/null || echo "")
          if [[ -z "$pr_data" ]]; then
            echo "⚠️ ERROR: Could not fetch PR data for PR #$pr_number"
            echo "Rerunning now to show the error message:"
            gh api "$pr_path"
            exit 1
          fi

          source_branch=$(echo "$pr_data" | jq -r '.head.ref // empty')
          target_branch=$(echo "$pr_data" | jq -r '.base.ref // empty')
          if [[ -z "$source_branch" ]]; then
            echo "⚠️ ERROR: Could not resolve source branch for PR #$pr_number"
            exit 1
          fi
          if [[ -z "$target_branch" ]]; then
            echo "⚠️ ERROR: Could not resolve target branch for PR #$pr_number"
            exit 1
          fi

          CI_VARS["pr-title"]=$(echo "$pr_data" | jq -r '.title // empty')
          CI_VARS["pr-draft"]=$(echo "$pr_data" | jq -r '.draft // false')
          CI_VARS["pr-url"]="https://github.com/$target_repo_name_full/pull/$pr_number"

          CI_VARS["pr-source-git-branch"]="$source_branch"
          CI_VARS["pr-source-repo-name-full"]=$(echo "$pr_data" | jq -r '.head.repo.full_name // empty')
          CI_VARS["pr-source-repo-owner"]=$(echo "$pr_data" | jq -r '.head.repo.owner.login // empty')
          CI_VARS["pr-source-repo-name"]=$(echo "$pr_data" | jq -r '.head.repo.name // empty')
          CI_VARS["pr-source-repo-is-fork"]="${{ github.event.pull_request.head.repo.fork }}"
          CI_VARS["pr-source-git-ref"]="refs/heads/$source_branch"
          CI_VARS["pr-source-git-sha"]=$(echo "$pr_data" | jq -r '.head.sha // empty')

          if [[ "${{ github.event_name }}" == "pull_request" || "${{ github.event_name }}" == "pull_request_target" ]]; then
            context_pr_number="${{ github.event.pull_request.number }}"

            if [[ ! -z "$context_pr_number" && ("$context_pr_number" != "$pr_number") && ("${{ github.event_name }}" == "pull_request" || "${{ github.event_name }}" == "pull_request_target") ]]; then
              echo "ℹ️ NOTICE: Context PR number ($context_pr_number) does not match expected PR number ($pr_number). We'll ignore github context..."

            else
              echo "ℹ️ Context PR number ($context_pr_number) matches expected PR number ($pr_number). Using the explicit SHA from github context..."

              CI_VARS["pr-source-git-ref"]="refs/heads/${{ github.head_ref != '' && github.head_ref || github.ref_name }}"
              CI_VARS["pr-source-git-sha"]="${{ github.event.pull_request.head.sha != '' && github.event.pull_request.head.sha || github.sha }}"
            fi
          fi

          # PR Target (base) variables
          CI_VARS["pr-target-git-branch"]="$target_branch"
          CI_VARS["pr-target-git-ref"]="refs/heads/$target_branch"
          CI_VARS["pr-target-git-sha"]=$(echo "$pr_data" | jq -r '.base.sha // empty')
          CI_VARS["pr-target-repo-name"]=$(echo "$pr_data" | jq -r '.base.repo.name // empty')
          CI_VARS["pr-target-repo-name-full"]=$(echo "$pr_data" | jq -r '.base.repo.full_name // empty')
          CI_VARS["pr-target-repo-owner"]=$(echo "$pr_data" | jq -r '.base.repo.owner.login // empty')

          # Set "resolved" vars to the PR source (head)
          CI_VARS["resolved-repo-name"]="${CI_VARS["pr-source-repo-name"]}"
          CI_VARS["resolved-repo-name-full"]="${CI_VARS["pr-source-repo-name-full"]}"
          CI_VARS["resolved-repo-owner"]="${CI_VARS["pr-source-repo-owner"]}"
          CI_VARS["resolved-git-branch"]="${CI_VARS["pr-source-git-branch"]}"
          CI_VARS["resolved-git-ref"]="${CI_VARS["pr-source-git-ref"]}"
          CI_VARS["resolved-git-sha"]="${CI_VARS["pr-source-git-sha"]}"
        fi

        # Comment Variables
        CI_VARS["comment-id"]="${{ steps.resolve-comment-id.outputs.comment-id }}"
        if [[ -n "${{ github.event.comment.id }}" ]]; then
          CI_VARS["comment-url"]="https://github.com/$target_repo_name_full/issues/${{ github.event.issue.number != '' && github.event.issue.number || github.event.pull_request.number }}#issuecomment-${{ github.event.comment.id }}"
        else
          CI_VARS["comment-url"]=""
        fi

        # Output each CI variable that has a value
        for var_name in "${!CI_VARS[@]}"; do
          var_value="${CI_VARS[$var_name]}"
          if [[ -n "$var_value" && "$var_value" != "null" && "$var_value" != "" ]]; then
            echo "$var_name=$var_value" >> "$GITHUB_OUTPUT"
            echo "Resolved CI variable: $var_name = $var_value"
          else
            echo "$var_name=" >> "$GITHUB_OUTPUT"
            echo "Resolved CI variable: $var_name = (empty)"
          fi
        done

        # Store CI variables for merge step
        ci_vars_json="{}"
        for var_name in "${!CI_VARS[@]}"; do
          var_value="${CI_VARS[$var_name]}"
          if [[ -n "$var_value" && "$var_value" != "null" && "$var_value" != "" ]]; then
            ci_vars_json=$(echo "$ci_vars_json" | jq --arg key "$var_name" --arg value "$var_value" '. + {($key): $value}')
          fi
        done
        # Make JSON compact for GITHUB_ENV
        ci_vars_json_compact=$(echo "$ci_vars_json" | jq -c .)
        echo "CI_VARS_JSON=$ci_vars_json_compact" >> "$GITHUB_ENV"

    # Process Jinja inputs using external action if jinja_inputs provided
    - id: process-jinja
      if: ${{ inputs.jinja_inputs != '' }}
      shell: bash
      run: |
        # Create Jinja template to process jinja_inputs
        > "$TEMP_JINJA_TEMPLATE"  # Clear the file first

        echo "=== Jinja inputs data ==="
        echo '${{ inputs.jinja_inputs }}'
        echo "=== Jinja inputs data ==="

        while IFS= read -r line; do
          # Debug: Show what line we're processing
          echo "DEBUG: Processing line: '$line'"

          # Skip empty lines and comments
          [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

          # Split on first = character
          if [[ "$line" =~ ^([^=]+)=(.*)$ ]]; then
            var_name="${BASH_REMATCH[1]}"
            expression="${BASH_REMATCH[2]}"

            # Trim whitespace from variable name
            var_name=$(echo "$var_name" | xargs)

            # Append to template file - each line will be VAR_NAME={{ expression }}
            NEW_JINJA_LINE="${var_name}={{ ${expression} }}"
            # Debug: Show what we're about to write
            echo "DEBUG: Adding to template: ${NEW_JINJA_LINE}"

            echo "$NEW_JINJA_LINE" >> "$TEMP_JINJA_TEMPLATE"
          fi
        done <<< "${{ format('{0}{1}', inputs.jinja_inputs, '\n')  }}"
        # End file with newline
        echo "" >> "$TEMP_JINJA_TEMPLATE"

        # Debug: Print the template file contents
        echo "=== Generated Jinja template ==="
        cat "$TEMP_JINJA_TEMPLATE"
        echo "=== End template ==="

        # Create variables file with current context + jinja_inputs
        cat > "$TEMP_VARS_FILE" << VARS_EOF
        {
          "jinja_inputs": $(echo "$JINJA_INPUTS_DATA" | jq -Rs .)
        }
        VARS_EOF

        # Add existing resolved variables to the context
        if [[ -f "$TEMP_VARS_FILE" ]]; then
          # Merge with initial resolved vars if any exist
          echo "Using variables file: $TEMP_VARS_FILE"
        fi

    - id: render-jinja
      if: ${{ inputs.jinja_inputs != '' }}
      uses: lexty/jinja2-renderer@v1
      with:
        template_path: ${{ env.TEMP_JINJA_TEMPLATE }}
        output_path: ${{ env.TEMP_JINJA_OUTPUT }}
        variables_file: ${{ env.TEMP_VARS_FILE }}
        environment_variables: 'false'
        strict: 'false'

    - id: merge-results
      shell: bash
      run: |
        declare -A RESOLVED_VARS

        # Re-load static variables
        if [[ -n "${{ inputs.static_inputs }}" ]]; then
          while IFS= read -r line; do
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
            if [[ "$line" =~ ^([^=]+)=(.*)$ ]]; then
              var_name="${BASH_REMATCH[1]}"
              var_value="${BASH_REMATCH[2]}"
              var_name=$(echo "$var_name" | xargs)
              RESOLVED_VARS["$var_name"]="$var_value"
            fi
          done <<< "${{ inputs.static_inputs }}"
        fi

        # Add CI variables to RESOLVED_VARS
        if [[ -n "$CI_VARS_JSON" ]]; then
          echo "Adding standard CI variables..."
          # Parse CI_VARS_JSON and add to RESOLVED_VARS
          while IFS="=" read -r key value; do
            if [[ -n "$key" && -n "$value" ]]; then
              RESOLVED_VARS["$key"]="$value"
              echo "Added CI variable: $key = $value"
              # Also output as individual GitHub Action output
              echo "$key=$value" >> "$GITHUB_OUTPUT"
            fi
          done < <(echo "$CI_VARS_JSON" | jq -r 'to_entries[] | "\(.key)=\(.value)"' 2>/dev/null || echo "")
        fi

        # Process jinja results if they exist
        if [[ -f "$TEMP_JINJA_OUTPUT" ]]; then
          echo "=== Jinja output file contents ==="
          cat "$TEMP_JINJA_OUTPUT"
          echo "=== End Jinja output ==="

          echo "Processing Jinja results..."
          while IFS= read -r line; do
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
            if [[ "$line" =~ ^([^=]+)=(.*)$ ]]; then
              var_name="${BASH_REMATCH[1]}"
              var_value="${BASH_REMATCH[2]}"
              var_name=$(echo "$var_name" | xargs)
              echo "Found resolved Jinja variable: $var_name = $var_value"
              RESOLVED_VARS["$var_name"]="$var_value"
              echo "$var_name=$var_value" >> "$GITHUB_OUTPUT"
            fi
          done < "$TEMP_JINJA_OUTPUT"

          # Clean up temp files
          rm -f "$TEMP_VARS_FILE" "$TEMP_JINJA_TEMPLATE" "$TEMP_JINJA_OUTPUT"
        fi

        # Build final JSON object with all resolved variables using jq
        json_payload="{}"
        for var_name in "${!RESOLVED_VARS[@]}"; do
          json_payload=$(echo "$json_payload" | jq --arg key "$var_name" --arg value "${RESOLVED_VARS[$var_name]}" '. + {($key): $value}')
        done

        # Make JSON compact for GITHUB_OUTPUT
        json_payload_compact=$(echo "$json_payload" | jq -c .)
        # Output the JSON object as 'custom'
        echo "custom=$json_payload_compact" >> "$GITHUB_OUTPUT"

        # Logging with GitHub Actions grouping for better scanability
        SHOULD_LOG="${{ inputs.log_outputs == 'true' || inputs.non_sensitive == 'true' }}"
        if [[ "$SHOULD_LOG" == "true" ]]; then
          echo "::group::🔧 Variable Resolution Results"
          echo "✅ Resolved variables:"
          for var_name in "${!RESOLVED_VARS[@]}"; do
            echo "  📝 $var_name: ${RESOLVED_VARS[$var_name]}"
          done
          echo "  📦 custom (JSON): $json_payload_compact"
          echo "::endgroup::"

          {
            echo "### 🔍 Variable Resolution Summary"
            for var_name in "${!RESOLVED_VARS[@]}"; do
              echo "- 📝 \`$var_name\`: ${RESOLVED_VARS[$var_name]}"
            done
            echo "- 📦 \`custom\`: $json_payload_compact"
          } >> "$GITHUB_STEP_SUMMARY"
        fi
