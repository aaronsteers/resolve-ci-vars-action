name: Resolve Vars
description: |
  Resolve variables using a combination of (1) pre-built resolutions, (2) static inputs, and (3) Jinja2 expressions.
inputs:
  static_inputs:
    description: >
      Variable assignments in key=value format (multiline string).
      Each line should be in the format: variable_name=value
  jinja_inputs:
    description: >
      Jinja2 expression to evaluate (e.g. user or default_user)
    required: false
  log_outputs:
    description: >
      Whether to log the resolved value (default false). This can be enabled if
      inputs and outputs are non-sensitive. you can also use this for sensitive
      values IIF you are confident you have masked sensitive values using
      GitHub secret masking.
    default: 'false'
    required: false
  non_sensitive:
    description: >
      Alias for log_outputs (true = show evaluated output)
    default: 'false'
    required: false
outputs:
  custom:
    value: ${{ steps.resolve.outputs.custom }}
    description: 'JSON-encoded object with all resolved custom values'
  var1:
    value: ${{ steps.resolve.outputs.var1 }}
    description: 'Custom user-defined output variable 1'
  var2:
    value: ${{ steps.resolve.outputs.var2 }}
    description: 'Custom user-defined output variable 2'
  var3:
    value: ${{ steps.resolve.outputs.var3 }}
    description: 'Custom user-defined output variable 3'
runs:
  using: "composite"
  steps:
    - id: resolve
      shell: bash
      run: |
        RESULT=""
        declare -A RESOLVED_VARS

        # Process static_inputs
        if [[ -n "${{ inputs.static_inputs }}" ]]; then
          echo "Processing static inputs..."

          # Read the multiline input and process each line
          while IFS= read -r line; do
            # Skip empty lines and comments
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

            # Split on first = character
            if [[ "$line" =~ ^([^=]+)=(.*)$ ]]; then
              var_name="${BASH_REMATCH[1]}"
              var_value="${BASH_REMATCH[2]}"

              # Trim whitespace from variable name
              var_name=$(echo "$var_name" | xargs)

              echo "Found variable: $var_name = $var_value"

              # Store in associative array
              RESOLVED_VARS["$var_name"]="$var_value"

              # Set the first non-empty value as result
              if [[ -z "$RESULT" && -n "$var_value" ]]; then
                RESULT="$var_value"
              fi

              # Output each variable
              echo "$var_name=$var_value" >> "$GITHUB_OUTPUT"
            fi
          done <<< "${{ inputs.static_inputs }}"
        fi

        # Output the result
        echo "result=$RESULT" >> "$GITHUB_OUTPUT"

        # Logging
        SHOULD_LOG="${{ inputs.log_outputs == 'true' || inputs.non_sensitive == 'true' }}"
        if [[ "$SHOULD_LOG" == "true" ]]; then
          echo "âœ… Resolved variables:"
          for var_name in "${!RESOLVED_VARS[@]}"; do
            echo "  $var_name: ${RESOLVED_VARS[$var_name]}"
          done
          echo "  result: $RESULT"

          {
            echo "### ðŸ” Variable Resolution Summary"
            for var_name in "${!RESOLVED_VARS[@]}"; do
              echo "- \`$var_name\`: ${RESOLVED_VARS[$var_name]}"
            done
            echo "- \`result\`: $RESULT"
          } >> "$GITHUB_STEP_SUMMARY"
        fi
